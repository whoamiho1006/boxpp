#pragma once
#include <boxpp/Base.hpp>
#include <boxpp/BaseTypes.hpp>

#include <boxpp/core/Name.hpp>
#include <boxpp/core/Barrior.hpp>
#include <boxpp/containers/Map.hpp>
#include <boxpp/containers/Queue.hpp>

#include <boxpp/SharedPtr.hpp>
#include <boxpp/core/Application.hpp>

namespace boxpp
{
#if BOX_COMPILE_BODY
	class FApplication;
	class FBaseApplication;
#endif

	namespace modules
	{
		class IModule;

		class BOXPP FModuleManager
		{
#if BOX_COMPILE_BODY
			friend class FApplication;
			friend class FBaseApplication;
#endif
		public:
			FASTINLINE static FModuleManager* Get() {
				if (IApplication* Engine = IApplication::Get()) {
					return Engine->GetModuleManager();
				}

				return nullptr;
			}

		protected:
			FModuleManager();
			~FModuleManager();

		public:
			/* Get engine module by name. */
			FASTINLINE static IModule* GetModule(const FName& Name) {
				if (FModuleManager* Manager = Get()) {
					return Manager->InternalGetModule(Name);
				}

				return nullptr;
			}

			/* Get weak-ptr of engine module by name. */
			FASTINLINE static TWeakPtr<IModule> GetModuleWeak(const FName& Name) {
				if (FModuleManager* Manager = Get()) {
					return Manager->InternalGetModuleWeak(Name);
				}

				return nullptr;
			}

			/* Get engine module by name. */
			template<typename TModule>
			FASTINLINE static TModule* GetModule(const FName& Name) {
				return dynamic_cast<TModule*>(GetModule(Name));
			}

			/* Get weak-ptr of engine module by name. */
			template<typename TModule>
			FASTINLINE static TWeakPtr<TModule> GetModuleWeak(const FName& Name) {
				return GetModuleWeak(Name);
			}

		private:
			FBarrior Barrior;

			IApplication* Engine;
			bool bStartup;

			TMap<FName, IModule*> Modules;

		protected:
			IModule* InternalGetModule(const FName& Name) const;
			TWeakPtr<IModule> InternalGetModuleWeak(const FName& Name) const;

		protected:
			/* Initialize/Finalize. called by engine. */
			void Initialize(IApplication* Engine);
			void Finalize();

		public:
			/* Register/Unregister method is only for engine. */
			bool Register(const FName& Name, IModule* Module);
			bool Unregister(const FName& Name, IModule* Module);

		protected:
			void Startup();
			void Shutdown();
		};
	}
}

FASTINLINE void BOX_RegisterModule(boxpp::IApplication* App,
	boxpp::modules::IModule* Module, const boxpp::FName& Name)
{
	if (boxpp::modules::FModuleManager* Manager = App->GetModuleManager()) {
		Manager->Register(Name, Module);
	}
}

#if BOX_COMPILE_SHARED_LIB || BOX_COMPILE_EXECUTABLE
#define BOX_IMPLEMENT_MODULE(ModuleInterface, Name) \
	class ModuleInterface##_AutoGenerated { \
		public: static ModuleInterface& Get() { \
			static ModuleInterface Module; \
			return Module; \
		} \
	}; \
	NO_MANGLED BOXEXTERN void BOX_ModuleMain(boxpp::IApplication* Engine) { \
		BOX_RegisterModule(Engine, &ModuleInterface##_AutoGenerated::Get(), #Name); \
	}
#else
#define BOX_IMPLEMENT_MODULE(ModuleInterface, Name)
#endif